:title: {revealjs_title}
:description: description
:backend: revealjs
:author: {revealjs_speaker}
:imagesdir: images

== Java-Projekte

[cols="1,4"]
|===
|Projekt|Thema

|Loom|Virtual Threads
|Valhalla|Value Objects
|Panama|Verknüpfung mit nativem Code
|Amber|Diverse kleinere Features (Pattern Matching, Textblocks)
|Coin|Kleinere Features für Java 7
|Graal|Ahead-of-time Compiler
|Jigsaw|Module in Java 9, modularisiertes JDK
|Skara|Umzug nach https://github.com/openjdk/jdk.git[GitHub]
|===

Siehe auch https://blogs.oracle.com/javamagazine/post/java-project-amber-lambda-loom-panama-valhalla[Major named Java projects].

== Der Name 'Valhalla'

Valhalla ist ein Konzept aus der nordischen Mythologie und bedeutet wörtlich 
„Halle der Gefallenen“. 

Valhalla ist der Ort, an dem tapfere Krieger nach ihrem Tod aufgenommen werden, 
wenn sie ehrenvoll auf dem Schlachtfeld gestorben sind. 
Die Walküren, mythologische Kriegerinnen, wählen diese
Helden aus und bringen sie nach Valhalla.

Die Krieger sind höchstwahrscheinlich über die Verwendung spitzer Gegenstände
(Englisch: pointy things, also Pointers) dorthin gekommen. Daher der Name. 

(Frei nach ChatGPT...)

== "Pointy things" in Java

Speicher-Layout in Java:

image::article/xy-points.png[]

[.step]
* 1990 (als die JVM designed wurde): Speicherzugriff so teuer wie add
* Heute (cache-miss):  1000x teurer +
  (mehrstufige Caches, parallelisierung von Instruktionen)
* Speicher-Layouts mit vielen Pointern passen nicht zu aktueller Hardware

[.columns]
== Ziel

image::article/flattened-points.png[]

* flacher (keine Indirektion) -> cache-efficient
* dichter (keine Header) -> memory-efficient

== Speicherzugriffe heute und damals

* In den frühen 1990igern, als die JVM designed wurde, dauerte ein Speicherzugriff
  in etwa genauso lang, wie die Ausführung einer Operation (z. B. Addition).
* Heute, mit mehrstufigen Caches und Parallelisierung einzelner Instruktionen,
  kann ein einzelner Cache-Miss solange dauern, wie die Ausführung von
  1000 Operationen.
* Speicherlayouts mit vielen Zeigern sind daher für heute Hardware 
  nicht ideal.
* Neben dem Speicherlayout gilt das auch für die Parameterübergabe.

== Valhalla

*Hintergrund:*

* Inline-Daten
* Seit 2014 (tatsächlich sollten value types schon Bestandteil der 1. Sparchversion sein)
* Artikel https://openjdk.org/projects/valhalla/design-notes/state-of-valhalla/01-background[State of Valhalla], von Brian Goetz, Dez. 2021

*Ziele:*

* Flacheres und dichteres Speicherlayout
* Keine Kompromisse bei Abstraktion und Typsicherheit
* Nicht nur _Flattening_ im Speicher, sondern auch bei der Parameterübergabe: +
  2 ints statt ein Pointer auf Point

== Ist-Situation bei Java

[.step]
* Zwei unterschiedliche Typsysteme: Primitive und Objekte
* Arrays von Primitiven sind anders als Arrays von Objekten
* Keine Generics mit primitiven Typen = viele _functional Interfaces_, 
  wie `IntPredicate` oder `IntToLongFunction`
* Problem beim Boxing/Unboxing: Identitiät geht verloren, NPEs, +
  Performancekosten bei Dereferenzierung
* `Integer` ist Box von `int`, `Integer[]` aber nicht von `int[]`
* Libraries (Collections, Streams) nicht per se für Primitive geeigenet,
  daher gibt es `IntStream` und `PrimitiveIterator.OfInt`.

== Kern Features von Valhalla

* Value Objects
* Primitive Classes
* Specialized Generics

Valhalla hat den Anspruch, die Kluft zwischen Primitiven und Objekten
zu beseitigen.

== `Integer` vs. `int`

--
[.heading]
Integer

[.step]
* Hat eine Speicheradresse (falls nicht wegoptimiert)
* Variable von Integer ist Zeiger auf Speicheradresse
* Zwei Variablen sind identisch bzgl. '==', wenn sie auf die gleiche Speicheradresse zeigen
* Ist ein java.lang.Object
* Wird vom Garbage-Collector weggeräumt
* Benötigt Header
--

--
[.heading]
int

[.step]
* Wird direkt gespeichert
* Variable von int enthält direkt den Wert
* Zwei Variablen sind identisch bzgl. '==', wenn sie den gleichen Wert haben
* Kann per Autoboxing in `Integer` umgewandelt werden
--

== Identität

Jedes `java.lang.Object` hat eine Identität (Speicheradresse)

* Es besteht ein Unterschied zwischen _das gleiche_ Objekt und _das selbe_ Objekt
* Objekte sind veränderbar (erschwert Caching)
* Ermöglicht Polymorphismus (Operationen sind auf Subklassen anwendbar), +
  da alle Oberklassen des gleiche Speicherlayout haben.
* Selbst von unveränderbaren Klassen (wie Integer) können (noch) veränderbare
  Subklassen gebildet werden.
* Viele Operationen setzen Identität voraus (==, synchronized, System::identityHashCode)
* Der Ursprung (die Speicheradresse) ist immer relevant

Das Hauptmerkmal von Valhalla ist, dass einige Objekte von ihrer Identität abrücken.

== Value-Objekt

* Ein Value-Objekt ist ein Objekt ohne Identität
* Die zugehörige Klasse ist eine Value-Klasse
* Value-Klassen sind immer _immutable_.
* Es können keine Subklassen von Value-Klassen gebildet werden.
* Die JVM kann solche Objekte beliebig replizieren.
* Der Ursprung (die vorherige Speicheradresse) ist irrelevant
* Bis auf die genannten Einschränkungen sind Value-Klassen ganz normale
  Java-Klassen mit allen zugehörigen Features
* Ein Value-Objekt kann `null` sein
* Hinter einer Value-Objekt Variable ist immer noch ein Pointer

== Primitv Klassen

* Primitv Klassen sind spezielle Value-Klassen die einen primitiven Typ repräsentieren
* Primitive können niemals `null` sein
* Primitive sind weniger stark gekapselt wie Referenztypen
* Primitive werden durch eine Sequenz einfacher Instanzvariablen umgesetzt
* Es gilt der Slogan von Valhalla: _Codes like a class, works like an int_
* Primitive haben Felder und Methoden und können jederzeit in Value-Objekte 
  umgewandelt werden (ohne den Overhead für Boxing)
* Arrays von Primitiven können wie Objekt-Arrays verwendet werden.
* Bestehende Primitive (int, long, ...) werden durch echte Klassen abgelöst

== Generics

* Jedes Primitv ist ein Value-Objekt oder kann als solches dargestellt werden
  (d. h. Pointer auf Primitive sind möglich)
* Jedes Value-Objekt ist ein Objekt und damit sind Generics wie `List<?>` auch 
  Primitive, wie `int` anwendbar.
* Spezielle Generics mit optimierten Implementierungen für diverse Primitive sind 
  machbar.

== Quellen

* Story (3 Teile): https://openjdk.org/projects/valhalla/design-notes/state-of-valhalla/01-background
* Projekt: https://openjdk.org/projects/valhalla/
* JDK: https://jdk.java.net/valhalla/
* JEP Overview: https://openjdk.org/jeps/0
* Value Classes and Objects: https://openjdk.org/jeps/401
* Enhanced Primitive Boxing: https://openjdk.org/jeps/402
