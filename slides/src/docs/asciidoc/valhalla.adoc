:title: {revealjs_title}
:description: description
:backend: revealjs
:author: {revealjs_speaker}
:imagesdir: images

== Agenda

. Einordnung und Hintergrund
. Problemstellung
. Lösungsansätze
. Blick in die Glaskugel

== Java-Projekte

[cols="1,4"]
|===
|Projekt|Thema

|Loom|Virtual Threads
|Valhalla|Value Objects
|Panama|Verknüpfung mit nativem Code
|Amber|Diverse kleinere Features (Pattern Matching, Textblocks)
|Babylon|Unterstützung anderer Programmiermodelle durch Code Reflection
|Coin|Kleinere Features für Java 7
|Graal|Ahead-of-time Compiler
|Jigsaw|Module in Java 9, modularisiertes JDK
|Skara|Umzug nach https://github.com/openjdk/jdk.git[GitHub]
|===

Siehe auch https://blogs.oracle.com/javamagazine/post/java-project-amber-lambda-loom-panama-valhalla[Major named Java projects]
oder https://openjdk.org/[openjdk.org].

[.columns]
== Der Name 'Valhalla'

[.two-col]
--
Valhalla ist ein Konzept aus der nordischen Mythologie und bedeutet wörtlich 
„Halle der Gefallenen“. 

Valhalla ist der Ort, an dem tapfere Krieger nach ihrem Tod aufgenommen werden, 
wenn sie ehrenvoll auf dem Schlachtfeld gestorben sind. 

Die Krieger sind höchstwahrscheinlich über die Verwendung spitzer Gegenstände
(Englisch: pointy things, also Pointers) dorthin gekommen. Daher der Name. 

(Frei nach ChatGPT...)
--

image::wikinger.webp[pdfwidth=7cm]

== "Pointy things" in Java

Speicher-Layout in Java:

image::article/xy-points.png[]

* Ein Pointer belegt 4 bis 8 Byte
* Ein Header belegt 12 Byte (notwendig für GC)
* Die Nutzdaten x bzw. y (int) belegen jeweils 4 Byte

[.columns]
== Ziel

image::article/flattened-points.png[]

* flacher (keine Indirektion) -> cache-efficient
* dichter (keine Header) -> memory-efficient

== Speicherzugriffe heute und damals

* In den frühen 1990igern, als die JVM designed wurde, dauerte ein Speicherzugriff
  in etwa genauso lang, wie die Ausführung einer Operation (z. B. Addition).
* Heute, mit mehrstufigen Caches und Parallelisierung einzelner Instruktionen,
  kann ein einzelner Cache-Miss solange dauern, wie die Ausführung von
  1000 Operationen.
* Speicherlayouts mit vielen Zeigern sind daher für heute Hardware 
  nicht ideal.
* Neben dem Speicherlayout gilt das auch für die Parameterübergabe.

== Valhalla

*Zum Projekt:*

* Arbeit seit 2014 +
  (tatsächlich sollten value types schon Bestandteil der 1. Sparchversion sein)
* Bekannt durch Artikel https://openjdk.org/projects/valhalla/design-notes/state-of-valhalla/01-background[State of Valhalla], von Brian Goetz, Dez. 2021
* Viel Bewegung in den letzten Monaten

*Ziele:*

* Flacheres und dichteres Speicherlayout
* Keine Kompromisse bei Abstraktion und Typsicherheit
* Nicht nur _Flattening_ im Speicher, sondern auch bei der Parameterübergabe: +
  2 ints statt ein Pointer auf Point

== Ist-Situation bei Java

[.step]
* Zwei unterschiedliche Typsysteme: Primitive und Objekte
* Arrays von Primitiven sind anders als Arrays von Objekten
* Keine Generics mit primitiven Typen = viele _functional Interfaces_, 
  wie `IntPredicate` oder `IntToLongFunction`
* Problem beim Boxing/Unboxing: Identitiät geht verloren, NPEs, +
  Performancekosten bei Dereferenzierung
* `Integer` ist Box von `int`, `Integer[]` aber nicht von `int[]`
* Libraries (Collections, Streams) nicht per se für Primitive geeigenet,
  daher gibt es `IntStream` und `PrimitiveIterator.OfInt`.

== Primtive vs. Objekte

|===
|Primitive (z. B. `int)|Objekte (z. B. `Integer`)

|Keine Identität|Identität
|`==` vergleicht den Wert|`==` vergleicht Identität (Speicheradresse)
|Built-in|Über Klassen deklariert
|Nicht nullable|Nullable
|Keine Members (Felder, Methoden, Konstuktoren)|Members (inkl. veränderbarer Felder)
|Keine Supertypes oder Subtypes|Vererbung von Klassen oder Interfaces
|Direkter Zugriff|Zugriff über Objekt-Referenz (Pointer)
|Default-Wert ist 0 (zero)|Default-Wert ist null
|Arrays sind _monomorphic_ |Arrays sind _covariant_
|Tearable under race (`long`)|Initialization safety guarantees
|Convertible to polymorphic objects|Polymorphic (`Number x = Integer.valueOf(1)`)
|===

== Identität

Jedes `java.lang.Object` hat eine Identität (Speicheradresse)

* Es besteht ein Unterschied zwischen _das gleiche_ Objekt und _das selbe_ Objekt
* Objekte sind veränderbar (erschwert Caching)
* Ermöglicht Polymorphismus (Operationen sind auf Subklassen anwendbar), +
  da alle Oberklassen des gleiche Speicherlayout haben.
* Selbst von unveränderbaren Klassen (wie Integer) können (noch) veränderbare
  Subklassen gebildet werden.
* Viele Operationen setzen Identität voraus (==, synchronized, System::identityHashCode)
* Der Ursprung (die Speicheradresse) ist immer relevant

Das Hauptmerkmal von Valhalla ist, dass einige Objekte von ihrer Identität abrücken.

== Value-Objekt

* Ein Value-Objekt ist ein Objekt ohne Identität
* Die zugehörige Klasse ist eine Value-Klasse
* Value-Klassen sind immer _immutable_, d. h. alle Felder sind final und nicht volatil.
* Es können keine Subklassen von (konkreten) Value-Klassen gebildet werden.
* Die JVM kann solche Objekte beliebig replizieren.
* Der Ursprung (die vorherige Speicheradresse) ist irrelevant
* Bis auf die genannten Einschränkungen sind Value-Klassen ganz normale
  Java-Klassen mit allen zugehörigen Features
* Ein Value-Objekt kann `null` sein
* Die VM bzw. der Compiler entscheidet, ob ein Value-Objekt referenziert 
  oder inline abgelegt wird.

== Primitv Klassen

* Primitv Klassen sind spezielle Value-Klassen die einen primitiven Typ repräsentieren
* Primitive können niemals `null` sein
* Primitive sind weniger stark gekapselt wie Referenztypen
* Primitive werden durch eine Sequenz einfacher Instanzvariablen umgesetzt
* Es gilt der Slogan von Valhalla: _Codes like a class, works like an int_
* Primitive haben Felder und Methoden und können jederzeit in Value-Objekte 
  umgewandelt werden (ohne den Overhead für Boxing)
* Arrays von Primitiven können wie Objekt-Arrays verwendet werden.
* Bestehende Primitive (int, long, ...) werden durch echte Klassen abgelöst

== Generics

* Jedes Primitv ist ein Value-Objekt oder kann als solches dargestellt werden
  (d. h. Pointer auf Primitive sind möglich)
* Jedes Value-Objekt ist ein Objekt und damit sind Generics wie `List<?>` auch 
  Primitive, wie `int` anwendbar.
* Spezielle Generics mit optimierten Implementierungen für diverse Primitive sind 
  machbar.

== Value Based Klassen

* Sind mit `@jdk.internal.ValueBased` annotiert (seit JDK 16)
* Beispiele sind `Optional`, `LocalDate`

.Eigenschaften:
* Sind final und immutable (können aber Refenzen auf veränderbare Objekte enthalten)
* `equals()`, `hashCode()` und `toString()` sind unabhängig von Identität
* Verwenden keine Operationen, die Identität voraussetzen (==, synchronized, ...)
* Können nur über Factory-Methoden erstellt werden, nicht über Konstruktoren
* Sind austauschbar mit anderen Objekten, die bzgl. `equals` gleich sind
* Können nicht zuverlässig mit `==` verglichen werden

Siehe auch https://docs.oracle.com/javase/8/docs/api/java/lang/doc-files/ValueBased.html[ValueBased]

== Kandiaten für Value-Klassen

.Optional
----
@jdk.internal.ValueBased
public final class Optional<T> {
----

.LocalDate
----
@jdk.internal.ValueBased
public final class LocalDate
        implements Temporal, TemporalAdjuster, ChronoLocalDate, Serializable {
----

.Integer
----
@jdk.internal.ValueBased
public final class Integer extends Number
        implements Comparable<Integer>, Constable, ConstantDesc {
----

.Byte
----
@jdk.internal.ValueBased
public final class Byte extends Number implements Comparable<Byte>, Constable {
----

.String
----
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence,
               Constable, ConstantDesc {
----

== Annotation und Marker Interfaces

.ValueBased (seit JDK 16)
----
@Retention(RetentionPolicy.RUNTIME)
@Target(value={TYPE})
public @interface ValueBased {
}
----

.Constable (seit JDK 12) -- Exemplar kann im _Constant Pool_ abgelegt werden
----
public interface Constable {
    Optional<? extends ConstantDesc> describeConstable();
}
----

.ConstantDesc (seit JDK 12)
----
public sealed interface ConstantDesc
        permits ClassDesc,
                MethodHandleDesc,
                MethodTypeDesc,
                Double,
                DynamicConstantDesc,
                Float,
                Integer,
                Long,
                String {
    Object resolveConstantDesc(MethodHandles.Lookup lookup) throws ReflectiveOperationException;
}
----

== Identitätssensible Operationen bei Value-Objekten

Gleichheit (`==`):: Bitweise vergleich der Felder (Primitive, Referenzen auf Identity-Objekte), 
  rekursiv bei referenzierten Value-Objekten
System::identityHashCode:: Analog zu `==` (noch in Klärung)
Object Methoden:: `equals`, `hashCode` und `toString` müssen konsistent mit `==` sein
Synchronization:: Compile-Fehler bzw. `IllegalMonitorStateException`
Weak references:: Nicht zulässig (Exception)
Serialization:: Im Objektgraphen wird Gleichheit nach wie vor mit `==` bestimmt


== Neue Marker-Interfaces

* `ValueObject`
* `IdentityObject`

---

.Für diese Interfaces gelten Einschränkungen
* Man kann prüfen, ob ein Objekt eines dieser Interfaces implementiert.
* Ein Klasse kann niemals beide Interfaces implementieren.
* Jedes Objekt implementiert genau eines dieser Interfaces. +
  Nötigenfalls wird das jeweilige Interface von der JVM ergänzt.
* `new Object()` erzeugt eine Subklasse von Object, die ein `IdentityObject` ist.
* Abstrakte Klassen implementieren per se keines der beiden Interfaces, +
  können dies aber explizit tun.

== Vererbung bei Value-Objekten

* Bei einem `IdentityObject` erzeugt der Compiler für jeden Konstruktur
  eine `<init>` Methode.
* Jede `<init>` Methode ruft eine `<init>` Methode der Oberklasse auf.
* Bei einem `ValueObject` erzeugt der Compiler für jeden Konstruktur +
  eine statische Factory Methode `<new>`.
* Die `<new>` Methode ruft *keine* `<init>` Methode einer abstraken Oberklasse auf.
* Sobald eine abstrakte Klasse einen nicht leeren Default-Konsturktur hat, +
  implementiert sie `IdentityObject`.
* (Abstrakte) Value-Klassen haben keine `<init>` Methode und +
  implementieren `ValueObject`.

== Definition von Primitiven

[source, Java]
----
primitive class Point implements Serializable {
    int x;
    int y;

    Point(int x, int y) { 
        this.x = x;
        this.y = y;
    }

    Point scale(int s) { 
        return new Point(s*x, s*y);
    }
}
----

* ValueObject
* Nicht nullable
* Keine _initialization safety guarantees_
* Bestehen nur aus Primitiven
* Keine rekursiven Typen möglich
* Flaches Speicher-Layout

== Polymorphismus bei Primitiven

* Primtive können abstrakte Klassen erweitern und Interfaces implementieren
* Zu jeder primitven Klasse gibt es 2 Typen:
   . Einen primitiven Typ, z. B. `Point`
   . Einen Referenztyp, z. B. `Point.ref`
* Zwischen den beiden Typen kann beliebig und nach Bedarf konvertiert werden
  (ähnlich dem Autoboxing)
* Polymorphismus ist nur für den Referenztyp gegeben

== Legacy Primitives

* `int` wird eine Primitive Klasse
* `Integer` ist Alias für `int.ref`

== VM-Erweiterungen für Value Classes

* Value-Klassen sind mit `ACC_VALUE` markiert
* Felder sind ggf. mit `ACC_STRICT` markiert (neu Verifier Regeln)
* Neues Attribut für Felder: `NullRestricted`
* Spracherweiterung zur Intialisierung von _null-restricted_ Arrays

== Primitive in der VM

* Jede derartige .class-Datei ist mit `ACC_PRIMTIVE` markiert
* Primtive Felder oder Paramter können den Q-Deskriptor (inline) + 
  statt dem L-Descriptor (Pointer) verwenden.
* Im Gegegensatz zum L-Descriptor muss Klassen mit Q-Deskriptor
  sofort geladen werden

== Flattening

* Flattening ist reine Compile- oder Laufzeitoptimierung
* Das Sprachmodell muss sich auf Programm-Semantik beschränken
* Die Herausforderung ist, die richtige Zusammenstellung von
  semantischen Hebeln, die einerseits Sinn für den Anwender machen,
  und anderseits für Performanceoptimierung genutzt werden können.
* Die Lösung ist, dem Anwender die Möglichkeit zu geben, besimmte 
  Freiheitsgrade explizit abzuwählen (final, not nullable).

== Objekte und Primtive (Stand heute)

|===
|Primitives|Objects

|No identity (pure values)|Identity
|== compares values 	|== compares object identity
|Built-in 	|Declared in classes
|Not nullable 	|Nullable
|No members (fields, methods, constructors) 	|Members (including mutable fields)
|No supertypes or subtypes 	|Class and interface inheritance
|Accessed directly 	|Accessed via object references
|Default value is zero 	|Default value is null
|Arrays of primitives are monomorphic 	|Arrays are covariant
|Tearable under race 	|Initialization safety guarantees
|Convertible to polymorphic objects 	|Polymorphic
|===


== Objekte und Primtive (nach Einführung von Valhalla)

|===
|Primitives|Objects

|Not nullable; default value is zero|Nullable; default value is null
|Tearable under race|Initialization safety guarantees
|Convertible to polymorphic objects|Polymorphic
|===

== Vorteile von Valhalla

|===
|Current World 	|Valhalla

|All objects have identity 	|Some objects have identity
|Fixed, built-in set of primitives 	|Open-ended set of primitives, declared with classes
|Primitives don’t have methods or supertypes 	|Primitives have classes, with methods and supertypes
|Primitives have ad-hoc boxes 	|Primitives have regularized companion reference types
|Boxes have accidental identity 	|Value objects have no identity
|Boxing and unboxing conversions 	|Value object and primitive value conversions, but same rules
|Primitive arrays are monomorphic |All arrays are covariant
|===

== Meine Bedenken bzgl. Valhalla

* Es entfällt die Möglichkeit zwei Pointer zu vergleichen
* Die Ausführungsdauer für `==` ist nicht mehr einfach vorhersagebar
* `new Object()` ist unschön, `Object` sollte abstrakt werden
* Auto-Unboxing führt zu verdeckten NullPointerExceptions, besser wäre
  ein striktes Typsystem wie bei Kotlin

== Ausblick

.Einführung erfolgt in 3 Phasen:
. Value Objects
. Primitiv Klassen, migration bestehender Primtive und universelle Generics
. Spezialisierte Generics

Die Einführung erfolgt in kleinen Schritten über viele JDK-Versionen hinweg.

== Plan

. 
. JEP 401: Value Classes
. JEP (JDK-8303099): Null restricted types (! and ? markers wie bei Kotlin)
. JEP (JDK-8316779): Null-restricted value classes types
. JEP 482: Pre-initialization context -> Strictly initialized fields
. JEP 402: Enhanced Primitive Boxing

== Strictly initialized fields

* Ein Feld ist _strictly initialized_, wenn es vor dem Aufruf von `super()` initialisiert wurde
* Alle Felder von Value-Klassen müssen das erfüllen
* Alle _null-restricted_ Felder (Felder die niemals null sein dürfen) müssen das erfüllen

== Quellen

* Story (3 Teile): https://openjdk.org/projects/valhalla/design-notes/state-of-valhalla/01-background
* Projekt: https://openjdk.org/projects/valhalla/
* JDK: https://jdk.java.net/valhalla/
* JEP Overview: https://openjdk.org/jeps/0
* Value Classes and Objects: https://openjdk.org/jeps/401
* Enhanced Primitive Boxing: https://openjdk.org/jeps/402
* Records vs. Value Types: https://www.beyondjava.net/records-vs-value-types
* https://cr.openjdk.org/~jrose/values/values-0.html
* Specialized Generics: https://cr.openjdk.org/~jrose/values/parametric-vm.pdf

== Links

* Projekt: https://openjdk.org/projects/valhalla/
* JDK: https://jdk.java.net/valhalla/
* JEP Overview: https://openjdk.org/jeps/0
* Value Classes and Objects: https://openjdk.org/jeps/401
* Enhanced Primitive Boxing: https://openjdk.org/jeps/402
* Story (3 Teile): https://openjdk.org/projects/valhalla/design-notes/state-of-valhalla/01-background

== Punkte

* Gegenwart: primitive Typen (int, ...), primitive Klassen (Integer, ...)
* String-Konstanten (inline)
* Integer.valueOf() statt Konstruktor (Warnung seit Java 16)
* value record vs. record
* Initializer-Code im Konstruktor vor Aufruf von super()
* Normale Initialisierungsreihenfolge im Konstruktur und Problem beim Aufruf von (überladenen Methoden)
* Problem bei Initialisierung (Felder müssen final befüllt sein, bevor super() aufgerufen wird)
